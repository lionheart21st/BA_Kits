###RMF模型的纯SQL实现

//尝试1   所有用户的所有消费记录都在这一张表中，先根据用户ID 计算出每个用户的消费记录的统计信息
#按用户id分组，计算各个用户的“最近订单日期”、“累计订单量”和“累计订单金额”
select  user_id '用户id',max(order_dt) '最近订单日期',count(order_amount)'累计订单量',sum(order_money)'累计订单金额'  
from customer
group by user_id;

--max(日期)得到的是 “最近”的日期（我的理解：本质上讲就是最大的时间戳）
--count(字段)得到的是 该字段的非空累计数（多少行非空），一般可以对应“现实中的啥啥 次数”  //如果，貌似，一张表中 所有字段都是非空的，count(任意一个字段)返回的值 是一样的！
--sum(字段)得到的是 该字段的数值累加和，一般可以对应“现实中的什么 之和”


#查询结果（部分）：
用户id	最近订单日期	累计订单量	累计订单金额
vs10000005	2019-12-27 14:42:48.000	6	189
vs10000621	2020-02-28	169	5704
vs10000627	2019-07-23	2	0
vs10000716	2020-02-28	131	2616
vs10000743	2019-03-15	1	20
vs10000757	2020-02-11 14:26:58.000	53	1104
vs10000773	2020-01-14	23	460
vs10000775	2019-11-18	3	2730
vs10000788	2019-08-09 14:01:34.000	4	144
vs10000794	2019-10-28 19:38:04.000	1	0
vs10000808	2020-01-16	33	640
vs10000812	2019-03-18	3	60
vs10000866	2019-12-18	51	571

//尝试2   “累计订单量”可以代表F 即消费频率（或者说 用户粘性），“累计订单金额”可以代表M 即用户价值（或者说 用户贡献度）
          用什么代表R 即近期活跃度？可以“最近订单日期” 日期越“近” 那么就是近期的活跃度越高！
                                    而计算日期的“远、近”，就需要设置一个“基准日期”，用“基准日期”减去每个“最近订单日期”

select  user_id '用户id',datediff('2021-01-01 00:00:00',max(order_dt)) '最近订单日期 R',count(order_amount)'累计订单量 F',sum(order_money)'累计订单金额 M'
from customer
group by user_id;

--datediff("日期",日期字段) 是一个日期计算函数，返回 "日期"减去日期字段的值 //这里指定了'2021-01-01 00:00:00'为“基准日期”
  注意：select datediff('2021-01-01','2020-01-01') 返回366  //select语句是可以“单独运行的”（一般用来调试函数的计算）

#查询结果（部分）：
用户id	最近订单日期 R	累计订单量 F	累计订单金额 M
vs10000005	371	6	189
vs10000621	308	169	5704
vs10000627	528	2	0
vs10000716	308	131	2616
vs10000743	658	1	20
vs10000757	325	53	1104
vs10000773	353	23	460
vs10000775	410	3	2730
vs10000788	511	4	144
vs10000794	431	1	0
vs10000808	351	33	640
vs10000812	655	3	60
vs10000866	380	51	571


//思考  RMF的评分怎么计算？采用大周老师课上讲的方法：先分别计算R、F、M的平均值，然后将用户的RFM值 减去RMF的均值，大于0 得分为1   小于0 得分为0

//尝试3 计算各个用户的RMF均值   //想一想：能不能 在总体数据（即 所有用户的所有消费记录）上直接计算 RMF均值？不行，因为 每个用户的最近日期 就不能确定了
        计算的思路：先要按照用户id 分组统计计算 各个用户的RMF值，然后 基于这个结果 再统计计算“各个用户的RMF均值”  

create view avg_rfm as     
select avg(datediff('2021-01-01 00:00:00',max_order_dt)) avg_R,avg(count_order_amount) avg_F,avg(sum_order_money) avg_M
from
(select  user_id,max(order_dt) max_order_dt,count(order_amount) count_order_amount,sum(order_money) sum_order_money
from customer
group by user_id) t_a

--把“分组统计”作为中间结果，就是把“分组统计”的语句 作为子查询 放在from子句中
--查询结果 建表、视图：一般是“先调试好查询语句（查询结果正确）”，然后在最前面 加一句 create table 表名 as  或者 create view 视图名 as

avg_R	avg_F	avg_M
462.9919	8.1498	186.59109311740892     //这就是全部用户的平均R、F、M值


//尝试4 计算各个用户的RMF评分
select user_id
,(case when datediff('2021-01-01',max(order_dt)) > (select avg_R from avg_rfm) then 1 else 0 end) R_level    #通过当前表的数据计算 与 另一张表（视图）的相应值 做比对，返回1 或者0
,(case when count(order_amount) > (select avg_F from avg_rfm) then 1 else 0 end) F_level
,(case when sum(order_money) > (select avg_M from avg_rfm) then 1 else 0 end) M_level
from customer
group by user_id;

--(case when)相当于“if else语句”,(case when)“直接”放在select子句中 相当于展示“(case when) 自身的计算结果”
--注意：select不仅能投影字段值，还能投影“计算值”

#查询结果（部分）：
user_id	R_level	F_level	M_level
vs10000005	0	0	1
vs10000621	0	1	1
vs10000627	1	0	0
vs10000716	0	1	1
vs10000743	1	0	0
vs10000757	0	1	1
vs10000773	0	1	1
vs10000775	0	0	1
vs10000788	1	0	0
vs10000794	0	0	0
vs10000808	0	1	1
vs10000812	1	0	0
vs10000866	0	1	1


//尝试5 基于用户的RMF得分，给用户打标签
create view customer_level_2 as
select user_id
,(case when R_level =1 and F_level=1 and M_level=1 then "高价值客户"  
       when R_level =0 and F_level=1 and M_level=1 then "重点保持客户"
       when R_level =1 and F_level=0 and M_level=1 then "重点发展客户"
       when R_level =0 and F_level=0 and M_level=1 then "重点挽留客户"
       when R_level =1 and F_level=1 and M_level=0 then "一般价值客户"
       when R_level =0 and F_level=1 and M_level=0 then "一般保持客户"
       when R_level =1 and F_level=0 and M_level=0 then "一般发展客户"
       when R_level =0 and F_level=0 and M_level=0 then "潜在客户"    
  end) user_label   
from
(select user_id
,(case when datediff('2021-01-01',max(order_dt)) > (select avg_R from avg_rfm) then 1 else 0 end) R_level  
,(case when count(order_amount) > (select avg_F from avg_rfm) then 1 else 0 end) F_level
,(case when sum(order_money) > (select avg_M from avg_rfm) then 1 else 0 end) M_level
from customer
group by user_id) t_a

--将用户RMF评分的语句 作为子查询 放在from子句中   //我的理解：貌似要在“中间结果表”上面 再做查询的话，就把“中间结果表的SQL语句”放在from子句中
--一条(case when)语句，可以有多个"when then else"。when 条件表达式 then 条件满足的怎么做 else 条件不满足的怎么做
                       多个"when then else"之间 是 没有“分隔(符)”的
  一条(case when)语句，只有 一对“case、end”，“case、end”标记着该语句的“起始与终点”
  
  

#小结：最终的生产代码
drop view if exists avg_rfm ;
create view avg_rfm as     
select avg(datediff('2021-01-01 00:00:00',max_order_dt)) avg_R,avg(count_order_amount) avg_F,avg(sum_order_money) avg_M
from
(select  user_id,max(order_dt) max_order_dt,count(order_amount) count_order_amount,sum(order_money) sum_order_money
from customer
group by user_id) t_a;

drop view if exists  customer_level_2;
create view customer_level_2 as
select user_id
,(case when R_level =1 and F_level=1 and M_level=1 then "高价值客户"  
       when R_level =0 and F_level=1 and M_level=1 then "重点保持客户"
       when R_level =1 and F_level=0 and M_level=1 then "重点发展客户"
       when R_level =0 and F_level=0 and M_level=1 then "重点挽留客户"
       when R_level =1 and F_level=1 and M_level=0 then "一般价值客户"
       when R_level =0 and F_level=1 and M_level=0 then "一般保持客户"
       when R_level =1 and F_level=0 and M_level=0 then "一般发展客户"
       when R_level =0 and F_level=0 and M_level=0 then "潜在客户"    
  end) user_label   
from
(select user_id
,(case when datediff('2021-01-01',max(order_dt)) > (select avg_R from avg_rfm) then 1 else 0 end) R_level  
,(case when count(order_amount) > (select avg_F from avg_rfm) then 1 else 0 end) F_level
,(case when sum(order_money) > (select avg_M from avg_rfm) then 1 else 0 end) M_level
from customer
group by user_id) t_a



#小结：
#与pandas实现的用户标签 做比对
SELECT a.用户id,a.label 方式一的用户标签,b.user_label 方式二的用户标签
from customer_level a    #customer_level表 保存了pandas实现的用户标签计算结果
join customer_level_2 b
on a.用户id = b.user_id 

#分类用户统计
select user_label '用户分类',count(user_label) '人数'
from customer_level_2
group by user_label

#返回结果：    与pandas的计算结果相比，有一点点小小的出入
user_label	count(user_label)
一般保持客户	3
一般发展客户	146
潜在客户	63
重点保持客户	24
重点发展客户	2
重点挽留客户	2
高价值客户	7


